import * as net from "net";
import {SyncRequestConfig} from "./SyncRequestConfig";
import {PostDataConfig} from "./PostDataConfig";

/**
 * A SyncRequest can be asked to terminate the request at exactly one moment using the 'terminate' method.
 * It can be useful is the goal is to ensure the request is processed by the server at exactly one specific moment
 */
export class SyncRequest extends net.Socket {

    /** Last character to send */
    private toSendLast: string = "";

    /** Creates a Concurrent Request */
    constructor(public readonly config: SyncRequestConfig) {
        super();
    }

    /** Connect and then start most of the headers
     * Beware of the timeouts
     */
    public async start(): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            this.once('error', reject.bind(this));

            this.once('connect', () => {
                let headers: string[] = [];

                headers = headers.concat(
                    [
                        this.config.method.toUpperCase() + " " + this.config.path + " HTTP/1.1",
                        "Host: " + this.config.host,
                        "Accept: */*",
                        "Accept-Language: en-us",
                        "Accept-Encoding: gzip, deflate",
                        "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
                    ]);

                if (this.config.method === 'post') {
                    let postData: PostDataConfig = this.config.postData as PostDataConfig;
                    let data: string = postData.data;
                    headers.push("Content-Type: " + postData.type);
                    headers.push("Content-Length: " + data.length);
                    headers.push("");
                    headers.push(data.substr(0, data.length - 1));
                    this.toSendLast = data[data.length - 1];
                } else {
                    this.toSendLast = "\r\n\r\n";
                }

                this.write(headers.join("\n"));
                resolve();
            });

            this.connect(this.config.port, this.config.host);
        });
    }

    /**
     * Terminate the request
     */
    public async terminate() {
        this.setNoDelay(true);
        this.write(this.toSendLast);
    }
}
